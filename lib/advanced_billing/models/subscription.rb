# advanced_billing
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

require 'date'
module AdvancedBilling
  # Subscription Model.
  class Subscription < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The subscription unique id within Chargify.
    # @return [Integer]
    attr_accessor :id

    # The state of a subscription.
    # * **Live States**
    #     * `active` - A normal, active subscription. It is not in a trial and
    # is paid and up to date.
    #     * `assessing` - An internal (transient) state that indicates a
    # subscription is in the middle of periodic assessment. Do not base any
    # access decisions in your app on this state, as it may not always be
    # exposed.
    #     * `pending` - An internal (transient) state that indicates a
    # subscription is in the creation process. Do not base any access decisions
    # in your app on this state, as it may not always be exposed.
    #     * `trialing` - A subscription in trialing state has a valid trial
    # subscription. This type of subscription may transition to active once
    # payment is received when the trial has ended. Otherwise, it may go to a
    # Problem or End of Life state.
    #     * `paused` - An internal state that indicates that your account with
    # Advanced Billing is in arrears.
    # * **Problem States**
    #     * `past_due` - Indicates that the most recent payment has failed, and
    # payment is past due for this subscription. If you have enabled our
    # automated dunning, this subscription will be in the dunning process
    # (additional status and callbacks from the dunning process will be
    # available in the future). If you are handling dunning and payment updates
    # yourself, you will want to use this state to initiate a payment update
    # from your customers.
    #     * `soft_failure` - Indicates that normal assessment/processing of the
    # subscription has failed for a reason that cannot be fixed by the Customer.
    # For example, a Soft Fail may result from a timeout at the gateway or
    # incorrect credentials on your part. The subscriptions should be retried
    # automatically. An interface is being built for you to review problems
    # resulting from these events to take manual action when needed.
    #     * `unpaid` - Indicates an unpaid subscription. A subscription is
    # marked unpaid if the retry period expires and you have configured your
    # [Dunning](https://maxio-chargify.zendesk.com/hc/en-us/articles/54055051410
    # 05) settings to have a Final Action of `mark the subscription unpaid`.
    # * **End of Life States**
    #     * `canceled` - Indicates a canceled subscription. This may happen at
    # your request (via the API or the web interface) or due to the expiration
    # of the
    # [Dunning](https://maxio-chargify.zendesk.com/hc/en-us/articles/54055051410
    # 05) process without payment. See the
    # [Reactivation](https://maxio-chargify.zendesk.com/hc/en-us/articles/540455
    # 9291021) documentation for info on how to restart a canceled subscription.
    #     While a subscription is canceled, its period will not advance, it will
    # not accrue any new charges, and Advanced Billing will not attempt to
    # collect the overdue balance.
    #     * `expired` - Indicates a subscription that has expired due to running
    # its normal life cycle. Some products may be configured to have an
    # expiration period. An expired subscription then is one that stayed active
    # until it fulfilled its full period.
    #     * `failed_to_create` - Indicates that signup has failed. (You may see
    # this state in a signup_failure webhook.)
    #     * `on_hold` - Indicates that a subscription’s billing has been
    # temporarily stopped. While it is expected that the subscription will
    # resume and return to active status, this is still treated as an “End of
    # Life” state because the customer is not paying for services during this
    # time.
    #     * `suspended` - Indicates that a prepaid subscription has used up all
    # their prepayment balance. If a prepayment is applied, it will return to an
    # active state.
    #     * `trial_ended` - A subscription in a trial_ended state is a
    # subscription that completed a no-obligation trial and did not have a card
    # on file at the expiration of the trial period. See [Product Pricing – No
    # Obligation
    # Trials](https://maxio-chargify.zendesk.com/hc/en-us/articles/5405246782221
    # ) for more details.
    # See [Subscription
    # States](https://maxio-chargify.zendesk.com/hc/en-us/articles/5404222005773
    # ) for more info about subscription states and state transitions.
    # @return [SubscriptionState]
    attr_accessor :state

    # Gives the current outstanding subscription balance in the number of cents.
    # @return [Integer]
    attr_accessor :balance_in_cents

    # Gives the total revenue from the subscription in the number of cents.
    # @return [Integer]
    attr_accessor :total_revenue_in_cents

    # (Added Nov 5 2013) The recurring amount of the product (and
    # version),currently subscribed. NOTE: this may differ from the current
    # price of,the product, if you’ve changed the price of the product but
    # haven’t,moved this subscription to a newer version.
    # @return [Integer]
    attr_accessor :product_price_in_cents

    # The version of the product for the subscription. Note that this is a
    # deprecated field kept for backwards-compatibility.
    # @return [Integer]
    attr_accessor :product_version_number

    # Timestamp relating to the end of the current (recurring) period (i.e.,when
    # the next regularly scheduled attempted charge will occur)
    # @return [DateTime]
    attr_accessor :current_period_ends_at

    # Timestamp that indicates when capture of payment will be tried or,retried.
    # This value will usually track the current_period_ends_at, but,will diverge
    # if a renewal payment fails and must be retried. In that,case, the
    # current_period_ends_at will advance to the end of the next,period (time
    # doesn’t stop because a payment was missed) but the,next_assessment_at will
    # be scheduled for the auto-retry time (i.e. 24,hours in the future, in some
    # cases)
    # @return [DateTime]
    attr_accessor :next_assessment_at

    # Timestamp for when the trial period (if any) began
    # @return [DateTime]
    attr_accessor :trial_started_at

    # Timestamp for when the trial period (if any) ended
    # @return [DateTime]
    attr_accessor :trial_ended_at

    # Timestamp for when the subscription began (i.e. when it came out of trial,
    # or when it began in the case of no trial)
    # @return [DateTime]
    attr_accessor :activated_at

    # Timestamp giving the expiration date of this subscription (if any)
    # @return [DateTime]
    attr_accessor :expires_at

    # The creation date for this subscription
    # @return [DateTime]
    attr_accessor :created_at

    # The date of last update for this subscription
    # @return [DateTime]
    attr_accessor :updated_at

    # Seller-provided reason for, or note about, the cancellation.
    # @return [String]
    attr_accessor :cancellation_message

    # The process used to cancel the subscription, if the subscription has been
    # canceled. It is nil if the subscription's state is not canceled.
    # @return [CancellationMethod]
    attr_accessor :cancellation_method

    # Whether or not the subscription will (or has) canceled at the end of the
    # period.
    # @return [TrueClass | FalseClass]
    attr_accessor :cancel_at_end_of_period

    # The timestamp of the most recent cancellation
    # @return [DateTime]
    attr_accessor :canceled_at

    # Timestamp relating to the start of the current (recurring) period
    # @return [DateTime]
    attr_accessor :current_period_started_at

    # Only valid for webhook payloads The previous state for webhooks that have
    # indicated a change in state. For normal API calls, this will always be the
    # same as the state (current state)
    # @return [SubscriptionState]
    attr_accessor :previous_state

    # The ID of the transaction that generated the revenue
    # @return [Integer]
    attr_accessor :signup_payment_id

    # The revenue, formatted as a string of decimal separated dollars and,cents,
    # from the subscription signup ($50.00 would be formatted as,50.00)
    # @return [String]
    attr_accessor :signup_revenue

    # Timestamp for when the subscription is currently set to cancel.
    # @return [DateTime]
    attr_accessor :delayed_cancel_at

    # (deprecated) The coupon code of the single coupon currently applied to the
    # subscription. See coupon_codes instead as subscriptions can now have more
    # than one coupon.
    # @return [String]
    attr_accessor :coupon_code

    # The day of the month that the subscription will charge according to
    # calendar billing rules, if used.
    # @return [String]
    attr_accessor :snap_day

    # The type of payment collection to be used in the subscription. For legacy
    # Statements Architecture valid options are - `invoice`, `automatic`. For
    # current Relationship Invoicing Architecture valid options are -
    # `remittance`, `automatic`, `prepaid`.
    # @return [CollectionMethod]
    attr_accessor :payment_collection_method

    # The type of payment collection to be used in the subscription. For legacy
    # Statements Architecture valid options are - `invoice`, `automatic`. For
    # current Relationship Invoicing Architecture valid options are -
    # `remittance`, `automatic`, `prepaid`.
    # @return [Customer]
    attr_accessor :customer

    # The type of payment collection to be used in the subscription. For legacy
    # Statements Architecture valid options are - `invoice`, `automatic`. For
    # current Relationship Invoicing Architecture valid options are -
    # `remittance`, `automatic`, `prepaid`.
    # @return [Product]
    attr_accessor :product

    # The type of payment collection to be used in the subscription. For legacy
    # Statements Architecture valid options are - `invoice`, `automatic`. For
    # current Relationship Invoicing Architecture valid options are -
    # `remittance`, `automatic`, `prepaid`.
    # @return [CreditCardPaymentProfile]
    attr_accessor :credit_card

    # The type of payment collection to be used in the subscription. For legacy
    # Statements Architecture valid options are - `invoice`, `automatic`. For
    # current Relationship Invoicing Architecture valid options are -
    # `remittance`, `automatic`, `prepaid`.
    # @return [NestedSubscriptionGroup]
    attr_accessor :group

    # The type of payment collection to be used in the subscription. For legacy
    # Statements Architecture valid options are - `invoice`, `automatic`. For
    # current Relationship Invoicing Architecture valid options are -
    # `remittance`, `automatic`, `prepaid`.
    # @return [BankAccountPaymentProfile]
    attr_accessor :bank_account

    # The payment profile type for the active profile on file.
    # @return [String]
    attr_accessor :payment_type

    # The subscription's unique code that can be given to referrals.
    # @return [String]
    attr_accessor :referral_code

    # If a delayed product change is scheduled, the ID of the product that the
    # subscription will be changed to at the next renewal.
    # @return [Integer]
    attr_accessor :next_product_id

    # If a delayed product change is scheduled, the handle of the product that
    # the subscription will be changed to at the next renewal.
    # @return [String]
    attr_accessor :next_product_handle

    # (deprecated) How many times the subscription's single coupon has been
    # used. This field has no replacement for multiple coupons.
    # @return [Integer]
    attr_accessor :coupon_use_count

    # (deprecated) How many times the subscription's single coupon may be used.
    # This field has no replacement for multiple coupons.
    # @return [Integer]
    attr_accessor :coupon_uses_allowed

    # If the subscription is canceled, this is their churn code.
    # @return [String]
    attr_accessor :reason_code

    # The date the subscription is scheduled to automatically resume from the
    # on_hold state.
    # @return [DateTime]
    attr_accessor :automatically_resume_at

    # An array for all the coupons attached to the subscription.
    # @return [Array[String]]
    attr_accessor :coupon_codes

    # The ID of the offer associated with the subscription.
    # @return [Integer]
    attr_accessor :offer_id

    # On Relationship Invoicing, the ID of the individual paying for the
    # subscription. Defaults to the Customer ID unless the 'Customer Hierarchies
    # & WhoPays' feature is enabled.
    # @return [Integer]
    attr_accessor :payer_id

    # The balance in cents plus the estimated renewal amount in cents. Returned
    # ONLY for readSubscription operation as it's compute intensive operation.
    # @return [Integer]
    attr_accessor :current_billing_amount_in_cents

    # The product price point currently subscribed to.
    # @return [Integer]
    attr_accessor :product_price_point_id

    # Price point type. We expose the following types:
    # 1. **default**: a price point that is marked as a default price for a
    # certain product.
    # 2. **custom**: a custom price point.
    # 3. **catalog**: a price point that is **not** marked as a default price
    # for a certain product and is **not** a custom one.
    # @return [PricePointType]
    attr_accessor :product_price_point_type

    # If a delayed product change is scheduled, the ID of the product price
    # point that the subscription will be changed to at the next renewal.
    # @return [Integer]
    attr_accessor :next_product_price_point_id

    # On Relationship Invoicing, the number of days before a renewal invoice is
    # due.
    # @return [Integer]
    attr_accessor :net_terms

    # For European sites subject to PSD2 and using 3D Secure, this can be used
    # to reference a previous transaction for the customer. This will ensure the
    # card will be charged successfully at renewal.
    # @return [Integer]
    attr_accessor :stored_credential_transaction_id

    # The reference value (provided by your app) for the subscription itelf.
    # @return [String]
    attr_accessor :reference

    # The timestamp of the most recent on hold action.
    # @return [DateTime]
    attr_accessor :on_hold_at

    # Boolean representing whether the subscription is prepaid and currently in
    # dunning. Only returned for Relationship Invoicing sites with the feature
    # enabled
    # @return [TrueClass | FalseClass]
    attr_accessor :prepaid_dunning

    # Additional coupon data. To use this data you also have to include the
    # following param in the request`include[]=coupons`.
    # Only in Read Subscription Endpoint.
    # @return [Array[SubscriptionIncludedCoupon]]
    attr_accessor :coupons

    # Enable Communication Delay feature, making sure no communication (email or
    # SMS) is sent to the Customer between 9PM and 8AM in time zone set by the
    # `dunning_communication_delay_time_zone` attribute.
    # @return [TrueClass | FalseClass]
    attr_accessor :dunning_communication_delay_enabled

    # Time zone for the Dunning Communication Delay feature.
    # @return [String]
    attr_accessor :dunning_communication_delay_time_zone

    # Time zone for the Dunning Communication Delay feature.
    # @return [TrueClass | FalseClass]
    attr_accessor :receives_invoice_emails

    # Time zone for the Dunning Communication Delay feature.
    # @return [String]
    attr_accessor :locale

    # Time zone for the Dunning Communication Delay feature.
    # @return [String]
    attr_accessor :currency

    # Time zone for the Dunning Communication Delay feature.
    # @return [DateTime]
    attr_accessor :scheduled_cancellation_at

    # Time zone for the Dunning Communication Delay feature.
    # @return [Integer]
    attr_accessor :credit_balance_in_cents

    # Time zone for the Dunning Communication Delay feature.
    # @return [Integer]
    attr_accessor :prepayment_balance_in_cents

    # Time zone for the Dunning Communication Delay feature.
    # @return [PrepaidConfiguration]
    attr_accessor :prepaid_configuration

    # Returned only for list/read Subscription operation when
    # `include[]=self_service_page_token` parameter is provided.
    # @return [String]
    attr_accessor :self_service_page_token

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['id'] = 'id'
      @_hash['state'] = 'state'
      @_hash['balance_in_cents'] = 'balance_in_cents'
      @_hash['total_revenue_in_cents'] = 'total_revenue_in_cents'
      @_hash['product_price_in_cents'] = 'product_price_in_cents'
      @_hash['product_version_number'] = 'product_version_number'
      @_hash['current_period_ends_at'] = 'current_period_ends_at'
      @_hash['next_assessment_at'] = 'next_assessment_at'
      @_hash['trial_started_at'] = 'trial_started_at'
      @_hash['trial_ended_at'] = 'trial_ended_at'
      @_hash['activated_at'] = 'activated_at'
      @_hash['expires_at'] = 'expires_at'
      @_hash['created_at'] = 'created_at'
      @_hash['updated_at'] = 'updated_at'
      @_hash['cancellation_message'] = 'cancellation_message'
      @_hash['cancellation_method'] = 'cancellation_method'
      @_hash['cancel_at_end_of_period'] = 'cancel_at_end_of_period'
      @_hash['canceled_at'] = 'canceled_at'
      @_hash['current_period_started_at'] = 'current_period_started_at'
      @_hash['previous_state'] = 'previous_state'
      @_hash['signup_payment_id'] = 'signup_payment_id'
      @_hash['signup_revenue'] = 'signup_revenue'
      @_hash['delayed_cancel_at'] = 'delayed_cancel_at'
      @_hash['coupon_code'] = 'coupon_code'
      @_hash['snap_day'] = 'snap_day'
      @_hash['payment_collection_method'] = 'payment_collection_method'
      @_hash['customer'] = 'customer'
      @_hash['product'] = 'product'
      @_hash['credit_card'] = 'credit_card'
      @_hash['group'] = 'group'
      @_hash['bank_account'] = 'bank_account'
      @_hash['payment_type'] = 'payment_type'
      @_hash['referral_code'] = 'referral_code'
      @_hash['next_product_id'] = 'next_product_id'
      @_hash['next_product_handle'] = 'next_product_handle'
      @_hash['coupon_use_count'] = 'coupon_use_count'
      @_hash['coupon_uses_allowed'] = 'coupon_uses_allowed'
      @_hash['reason_code'] = 'reason_code'
      @_hash['automatically_resume_at'] = 'automatically_resume_at'
      @_hash['coupon_codes'] = 'coupon_codes'
      @_hash['offer_id'] = 'offer_id'
      @_hash['payer_id'] = 'payer_id'
      @_hash['current_billing_amount_in_cents'] =
        'current_billing_amount_in_cents'
      @_hash['product_price_point_id'] = 'product_price_point_id'
      @_hash['product_price_point_type'] = 'product_price_point_type'
      @_hash['next_product_price_point_id'] = 'next_product_price_point_id'
      @_hash['net_terms'] = 'net_terms'
      @_hash['stored_credential_transaction_id'] =
        'stored_credential_transaction_id'
      @_hash['reference'] = 'reference'
      @_hash['on_hold_at'] = 'on_hold_at'
      @_hash['prepaid_dunning'] = 'prepaid_dunning'
      @_hash['coupons'] = 'coupons'
      @_hash['dunning_communication_delay_enabled'] =
        'dunning_communication_delay_enabled'
      @_hash['dunning_communication_delay_time_zone'] =
        'dunning_communication_delay_time_zone'
      @_hash['receives_invoice_emails'] = 'receives_invoice_emails'
      @_hash['locale'] = 'locale'
      @_hash['currency'] = 'currency'
      @_hash['scheduled_cancellation_at'] = 'scheduled_cancellation_at'
      @_hash['credit_balance_in_cents'] = 'credit_balance_in_cents'
      @_hash['prepayment_balance_in_cents'] = 'prepayment_balance_in_cents'
      @_hash['prepaid_configuration'] = 'prepaid_configuration'
      @_hash['self_service_page_token'] = 'self_service_page_token'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        id
        state
        balance_in_cents
        total_revenue_in_cents
        product_price_in_cents
        product_version_number
        current_period_ends_at
        next_assessment_at
        trial_started_at
        trial_ended_at
        activated_at
        expires_at
        created_at
        updated_at
        cancellation_message
        cancellation_method
        cancel_at_end_of_period
        canceled_at
        current_period_started_at
        previous_state
        signup_payment_id
        signup_revenue
        delayed_cancel_at
        coupon_code
        snap_day
        payment_collection_method
        customer
        product
        credit_card
        group
        bank_account
        payment_type
        referral_code
        next_product_id
        next_product_handle
        coupon_use_count
        coupon_uses_allowed
        reason_code
        automatically_resume_at
        coupon_codes
        offer_id
        payer_id
        current_billing_amount_in_cents
        product_price_point_id
        product_price_point_type
        next_product_price_point_id
        net_terms
        stored_credential_transaction_id
        reference
        on_hold_at
        prepaid_dunning
        coupons
        dunning_communication_delay_enabled
        dunning_communication_delay_time_zone
        receives_invoice_emails
        locale
        currency
        scheduled_cancellation_at
        credit_balance_in_cents
        prepayment_balance_in_cents
        prepaid_configuration
        self_service_page_token
      ]
    end

    # An array for nullable fields
    def self.nullables
      %w[
        current_period_ends_at
        next_assessment_at
        trial_started_at
        trial_ended_at
        activated_at
        expires_at
        cancellation_message
        cancellation_method
        cancel_at_end_of_period
        canceled_at
        current_period_started_at
        delayed_cancel_at
        coupon_code
        snap_day
        group
        payment_type
        referral_code
        next_product_id
        next_product_handle
        coupon_use_count
        coupon_uses_allowed
        reason_code
        automatically_resume_at
        offer_id
        payer_id
        next_product_price_point_id
        net_terms
        stored_credential_transaction_id
        reference
        on_hold_at
        dunning_communication_delay_time_zone
        receives_invoice_emails
        locale
        scheduled_cancellation_at
        prepaid_configuration
      ]
    end

    def initialize(id = SKIP,
                   state = SKIP,
                   balance_in_cents = SKIP,
                   total_revenue_in_cents = SKIP,
                   product_price_in_cents = SKIP,
                   product_version_number = SKIP,
                   current_period_ends_at = SKIP,
                   next_assessment_at = SKIP,
                   trial_started_at = SKIP,
                   trial_ended_at = SKIP,
                   activated_at = SKIP,
                   expires_at = SKIP,
                   created_at = SKIP,
                   updated_at = SKIP,
                   cancellation_message = SKIP,
                   cancellation_method = SKIP,
                   cancel_at_end_of_period = SKIP,
                   canceled_at = SKIP,
                   current_period_started_at = SKIP,
                   previous_state = SKIP,
                   signup_payment_id = SKIP,
                   signup_revenue = SKIP,
                   delayed_cancel_at = SKIP,
                   coupon_code = SKIP,
                   snap_day = SKIP,
                   payment_collection_method = CollectionMethod::AUTOMATIC,
                   customer = SKIP,
                   product = SKIP,
                   credit_card = SKIP,
                   group = SKIP,
                   bank_account = SKIP,
                   payment_type = SKIP,
                   referral_code = SKIP,
                   next_product_id = SKIP,
                   next_product_handle = SKIP,
                   coupon_use_count = SKIP,
                   coupon_uses_allowed = SKIP,
                   reason_code = SKIP,
                   automatically_resume_at = SKIP,
                   coupon_codes = SKIP,
                   offer_id = SKIP,
                   payer_id = SKIP,
                   current_billing_amount_in_cents = SKIP,
                   product_price_point_id = SKIP,
                   product_price_point_type = SKIP,
                   next_product_price_point_id = SKIP,
                   net_terms = SKIP,
                   stored_credential_transaction_id = SKIP,
                   reference = SKIP,
                   on_hold_at = SKIP,
                   prepaid_dunning = SKIP,
                   coupons = SKIP,
                   dunning_communication_delay_enabled = SKIP,
                   dunning_communication_delay_time_zone = SKIP,
                   receives_invoice_emails = SKIP,
                   locale = SKIP,
                   currency = SKIP,
                   scheduled_cancellation_at = SKIP,
                   credit_balance_in_cents = SKIP,
                   prepayment_balance_in_cents = SKIP,
                   prepaid_configuration = SKIP,
                   self_service_page_token = SKIP,
                   additional_properties = {})
      @id = id unless id == SKIP
      @state = state unless state == SKIP
      @balance_in_cents = balance_in_cents unless balance_in_cents == SKIP
      @total_revenue_in_cents = total_revenue_in_cents unless total_revenue_in_cents == SKIP
      @product_price_in_cents = product_price_in_cents unless product_price_in_cents == SKIP
      @product_version_number = product_version_number unless product_version_number == SKIP
      @current_period_ends_at = current_period_ends_at unless current_period_ends_at == SKIP
      @next_assessment_at = next_assessment_at unless next_assessment_at == SKIP
      @trial_started_at = trial_started_at unless trial_started_at == SKIP
      @trial_ended_at = trial_ended_at unless trial_ended_at == SKIP
      @activated_at = activated_at unless activated_at == SKIP
      @expires_at = expires_at unless expires_at == SKIP
      @created_at = created_at unless created_at == SKIP
      @updated_at = updated_at unless updated_at == SKIP
      @cancellation_message = cancellation_message unless cancellation_message == SKIP
      @cancellation_method = cancellation_method unless cancellation_method == SKIP
      @cancel_at_end_of_period = cancel_at_end_of_period unless cancel_at_end_of_period == SKIP
      @canceled_at = canceled_at unless canceled_at == SKIP
      unless current_period_started_at == SKIP
        @current_period_started_at =
          current_period_started_at
      end
      @previous_state = previous_state unless previous_state == SKIP
      @signup_payment_id = signup_payment_id unless signup_payment_id == SKIP
      @signup_revenue = signup_revenue unless signup_revenue == SKIP
      @delayed_cancel_at = delayed_cancel_at unless delayed_cancel_at == SKIP
      @coupon_code = coupon_code unless coupon_code == SKIP
      @snap_day = snap_day unless snap_day == SKIP
      unless payment_collection_method == SKIP
        @payment_collection_method =
          payment_collection_method
      end
      @customer = customer unless customer == SKIP
      @product = product unless product == SKIP
      @credit_card = credit_card unless credit_card == SKIP
      @group = group unless group == SKIP
      @bank_account = bank_account unless bank_account == SKIP
      @payment_type = payment_type unless payment_type == SKIP
      @referral_code = referral_code unless referral_code == SKIP
      @next_product_id = next_product_id unless next_product_id == SKIP
      @next_product_handle = next_product_handle unless next_product_handle == SKIP
      @coupon_use_count = coupon_use_count unless coupon_use_count == SKIP
      @coupon_uses_allowed = coupon_uses_allowed unless coupon_uses_allowed == SKIP
      @reason_code = reason_code unless reason_code == SKIP
      @automatically_resume_at = automatically_resume_at unless automatically_resume_at == SKIP
      @coupon_codes = coupon_codes unless coupon_codes == SKIP
      @offer_id = offer_id unless offer_id == SKIP
      @payer_id = payer_id unless payer_id == SKIP
      unless current_billing_amount_in_cents == SKIP
        @current_billing_amount_in_cents =
          current_billing_amount_in_cents
      end
      @product_price_point_id = product_price_point_id unless product_price_point_id == SKIP
      @product_price_point_type = product_price_point_type unless product_price_point_type == SKIP
      unless next_product_price_point_id == SKIP
        @next_product_price_point_id =
          next_product_price_point_id
      end
      @net_terms = net_terms unless net_terms == SKIP
      unless stored_credential_transaction_id == SKIP
        @stored_credential_transaction_id =
          stored_credential_transaction_id
      end
      @reference = reference unless reference == SKIP
      @on_hold_at = on_hold_at unless on_hold_at == SKIP
      @prepaid_dunning = prepaid_dunning unless prepaid_dunning == SKIP
      @coupons = coupons unless coupons == SKIP
      unless dunning_communication_delay_enabled == SKIP
        @dunning_communication_delay_enabled =
          dunning_communication_delay_enabled
      end
      unless dunning_communication_delay_time_zone == SKIP
        @dunning_communication_delay_time_zone =
          dunning_communication_delay_time_zone
      end
      @receives_invoice_emails = receives_invoice_emails unless receives_invoice_emails == SKIP
      @locale = locale unless locale == SKIP
      @currency = currency unless currency == SKIP
      unless scheduled_cancellation_at == SKIP
        @scheduled_cancellation_at =
          scheduled_cancellation_at
      end
      @credit_balance_in_cents = credit_balance_in_cents unless credit_balance_in_cents == SKIP
      unless prepayment_balance_in_cents == SKIP
        @prepayment_balance_in_cents =
          prepayment_balance_in_cents
      end
      @prepaid_configuration = prepaid_configuration unless prepaid_configuration == SKIP
      @self_service_page_token = self_service_page_token unless self_service_page_token == SKIP

      # Add additional model properties to the instance.
      additional_properties.each do |_name, _value|
        instance_variable_set("@#{_name}", _value)
      end
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      id = hash.key?('id') ? hash['id'] : SKIP
      state = hash.key?('state') ? hash['state'] : SKIP
      balance_in_cents =
        hash.key?('balance_in_cents') ? hash['balance_in_cents'] : SKIP
      total_revenue_in_cents =
        hash.key?('total_revenue_in_cents') ? hash['total_revenue_in_cents'] : SKIP
      product_price_in_cents =
        hash.key?('product_price_in_cents') ? hash['product_price_in_cents'] : SKIP
      product_version_number =
        hash.key?('product_version_number') ? hash['product_version_number'] : SKIP
      current_period_ends_at = if hash.key?('current_period_ends_at')
                                 (DateTimeHelper.from_rfc3339(hash['current_period_ends_at']) if hash['current_period_ends_at'])
                               else
                                 SKIP
                               end
      next_assessment_at = if hash.key?('next_assessment_at')
                             (DateTimeHelper.from_rfc3339(hash['next_assessment_at']) if hash['next_assessment_at'])
                           else
                             SKIP
                           end
      trial_started_at = if hash.key?('trial_started_at')
                           (DateTimeHelper.from_rfc3339(hash['trial_started_at']) if hash['trial_started_at'])
                         else
                           SKIP
                         end
      trial_ended_at = if hash.key?('trial_ended_at')
                         (DateTimeHelper.from_rfc3339(hash['trial_ended_at']) if hash['trial_ended_at'])
                       else
                         SKIP
                       end
      activated_at = if hash.key?('activated_at')
                       (DateTimeHelper.from_rfc3339(hash['activated_at']) if hash['activated_at'])
                     else
                       SKIP
                     end
      expires_at = if hash.key?('expires_at')
                     (DateTimeHelper.from_rfc3339(hash['expires_at']) if hash['expires_at'])
                   else
                     SKIP
                   end
      created_at = if hash.key?('created_at')
                     (DateTimeHelper.from_rfc3339(hash['created_at']) if hash['created_at'])
                   else
                     SKIP
                   end
      updated_at = if hash.key?('updated_at')
                     (DateTimeHelper.from_rfc3339(hash['updated_at']) if hash['updated_at'])
                   else
                     SKIP
                   end
      cancellation_message =
        hash.key?('cancellation_message') ? hash['cancellation_message'] : SKIP
      cancellation_method =
        hash.key?('cancellation_method') ? hash['cancellation_method'] : SKIP
      cancel_at_end_of_period =
        hash.key?('cancel_at_end_of_period') ? hash['cancel_at_end_of_period'] : SKIP
      canceled_at = if hash.key?('canceled_at')
                      (DateTimeHelper.from_rfc3339(hash['canceled_at']) if hash['canceled_at'])
                    else
                      SKIP
                    end
      current_period_started_at = if hash.key?('current_period_started_at')
                                    (DateTimeHelper.from_rfc3339(hash['current_period_started_at']) if hash['current_period_started_at'])
                                  else
                                    SKIP
                                  end
      previous_state =
        hash.key?('previous_state') ? hash['previous_state'] : SKIP
      signup_payment_id =
        hash.key?('signup_payment_id') ? hash['signup_payment_id'] : SKIP
      signup_revenue =
        hash.key?('signup_revenue') ? hash['signup_revenue'] : SKIP
      delayed_cancel_at = if hash.key?('delayed_cancel_at')
                            (DateTimeHelper.from_rfc3339(hash['delayed_cancel_at']) if hash['delayed_cancel_at'])
                          else
                            SKIP
                          end
      coupon_code = hash.key?('coupon_code') ? hash['coupon_code'] : SKIP
      snap_day = hash.key?('snap_day') ? hash['snap_day'] : SKIP
      payment_collection_method =
        hash['payment_collection_method'] ||= CollectionMethod::AUTOMATIC
      customer = Customer.from_hash(hash['customer']) if hash['customer']
      product = Product.from_hash(hash['product']) if hash['product']
      credit_card = CreditCardPaymentProfile.from_hash(hash['credit_card']) if hash['credit_card']
      group = NestedSubscriptionGroup.from_hash(hash['group']) if hash['group']
      bank_account = BankAccountPaymentProfile.from_hash(hash['bank_account']) if
        hash['bank_account']
      payment_type = hash.key?('payment_type') ? hash['payment_type'] : SKIP
      referral_code = hash.key?('referral_code') ? hash['referral_code'] : SKIP
      next_product_id =
        hash.key?('next_product_id') ? hash['next_product_id'] : SKIP
      next_product_handle =
        hash.key?('next_product_handle') ? hash['next_product_handle'] : SKIP
      coupon_use_count =
        hash.key?('coupon_use_count') ? hash['coupon_use_count'] : SKIP
      coupon_uses_allowed =
        hash.key?('coupon_uses_allowed') ? hash['coupon_uses_allowed'] : SKIP
      reason_code = hash.key?('reason_code') ? hash['reason_code'] : SKIP
      automatically_resume_at = if hash.key?('automatically_resume_at')
                                  (DateTimeHelper.from_rfc3339(hash['automatically_resume_at']) if hash['automatically_resume_at'])
                                else
                                  SKIP
                                end
      coupon_codes = hash.key?('coupon_codes') ? hash['coupon_codes'] : SKIP
      offer_id = hash.key?('offer_id') ? hash['offer_id'] : SKIP
      payer_id = hash.key?('payer_id') ? hash['payer_id'] : SKIP
      current_billing_amount_in_cents =
        hash.key?('current_billing_amount_in_cents') ? hash['current_billing_amount_in_cents'] : SKIP
      product_price_point_id =
        hash.key?('product_price_point_id') ? hash['product_price_point_id'] : SKIP
      product_price_point_type =
        hash.key?('product_price_point_type') ? hash['product_price_point_type'] : SKIP
      next_product_price_point_id =
        hash.key?('next_product_price_point_id') ? hash['next_product_price_point_id'] : SKIP
      net_terms = hash.key?('net_terms') ? hash['net_terms'] : SKIP
      stored_credential_transaction_id =
        hash.key?('stored_credential_transaction_id') ? hash['stored_credential_transaction_id'] : SKIP
      reference = hash.key?('reference') ? hash['reference'] : SKIP
      on_hold_at = if hash.key?('on_hold_at')
                     (DateTimeHelper.from_rfc3339(hash['on_hold_at']) if hash['on_hold_at'])
                   else
                     SKIP
                   end
      prepaid_dunning =
        hash.key?('prepaid_dunning') ? hash['prepaid_dunning'] : SKIP
      # Parameter is an array, so we need to iterate through it
      coupons = nil
      unless hash['coupons'].nil?
        coupons = []
        hash['coupons'].each do |structure|
          coupons << (SubscriptionIncludedCoupon.from_hash(structure) if structure)
        end
      end

      coupons = SKIP unless hash.key?('coupons')
      dunning_communication_delay_enabled =
        hash.key?('dunning_communication_delay_enabled') ? hash['dunning_communication_delay_enabled'] : SKIP
      dunning_communication_delay_time_zone =
        hash.key?('dunning_communication_delay_time_zone') ? hash['dunning_communication_delay_time_zone'] : SKIP
      receives_invoice_emails =
        hash.key?('receives_invoice_emails') ? hash['receives_invoice_emails'] : SKIP
      locale = hash.key?('locale') ? hash['locale'] : SKIP
      currency = hash.key?('currency') ? hash['currency'] : SKIP
      scheduled_cancellation_at = if hash.key?('scheduled_cancellation_at')
                                    (DateTimeHelper.from_rfc3339(hash['scheduled_cancellation_at']) if hash['scheduled_cancellation_at'])
                                  else
                                    SKIP
                                  end
      credit_balance_in_cents =
        hash.key?('credit_balance_in_cents') ? hash['credit_balance_in_cents'] : SKIP
      prepayment_balance_in_cents =
        hash.key?('prepayment_balance_in_cents') ? hash['prepayment_balance_in_cents'] : SKIP
      prepaid_configuration = PrepaidConfiguration.from_hash(hash['prepaid_configuration']) if
        hash['prepaid_configuration']
      self_service_page_token =
        hash.key?('self_service_page_token') ? hash['self_service_page_token'] : SKIP

      # Clean out expected properties from Hash.
      names.each_value { |k| hash.delete(k) }

      # Create object from extracted values.
      Subscription.new(id,
                       state,
                       balance_in_cents,
                       total_revenue_in_cents,
                       product_price_in_cents,
                       product_version_number,
                       current_period_ends_at,
                       next_assessment_at,
                       trial_started_at,
                       trial_ended_at,
                       activated_at,
                       expires_at,
                       created_at,
                       updated_at,
                       cancellation_message,
                       cancellation_method,
                       cancel_at_end_of_period,
                       canceled_at,
                       current_period_started_at,
                       previous_state,
                       signup_payment_id,
                       signup_revenue,
                       delayed_cancel_at,
                       coupon_code,
                       snap_day,
                       payment_collection_method,
                       customer,
                       product,
                       credit_card,
                       group,
                       bank_account,
                       payment_type,
                       referral_code,
                       next_product_id,
                       next_product_handle,
                       coupon_use_count,
                       coupon_uses_allowed,
                       reason_code,
                       automatically_resume_at,
                       coupon_codes,
                       offer_id,
                       payer_id,
                       current_billing_amount_in_cents,
                       product_price_point_id,
                       product_price_point_type,
                       next_product_price_point_id,
                       net_terms,
                       stored_credential_transaction_id,
                       reference,
                       on_hold_at,
                       prepaid_dunning,
                       coupons,
                       dunning_communication_delay_enabled,
                       dunning_communication_delay_time_zone,
                       receives_invoice_emails,
                       locale,
                       currency,
                       scheduled_cancellation_at,
                       credit_balance_in_cents,
                       prepayment_balance_in_cents,
                       prepaid_configuration,
                       self_service_page_token,
                       hash)
    end

    def to_custom_current_period_ends_at
      DateTimeHelper.to_rfc3339(current_period_ends_at)
    end

    def to_custom_next_assessment_at
      DateTimeHelper.to_rfc3339(next_assessment_at)
    end

    def to_custom_trial_started_at
      DateTimeHelper.to_rfc3339(trial_started_at)
    end

    def to_custom_trial_ended_at
      DateTimeHelper.to_rfc3339(trial_ended_at)
    end

    def to_custom_activated_at
      DateTimeHelper.to_rfc3339(activated_at)
    end

    def to_custom_expires_at
      DateTimeHelper.to_rfc3339(expires_at)
    end

    def to_custom_created_at
      DateTimeHelper.to_rfc3339(created_at)
    end

    def to_custom_updated_at
      DateTimeHelper.to_rfc3339(updated_at)
    end

    def to_custom_canceled_at
      DateTimeHelper.to_rfc3339(canceled_at)
    end

    def to_custom_current_period_started_at
      DateTimeHelper.to_rfc3339(current_period_started_at)
    end

    def to_custom_delayed_cancel_at
      DateTimeHelper.to_rfc3339(delayed_cancel_at)
    end

    def to_custom_automatically_resume_at
      DateTimeHelper.to_rfc3339(automatically_resume_at)
    end

    def to_custom_on_hold_at
      DateTimeHelper.to_rfc3339(on_hold_at)
    end

    def to_custom_scheduled_cancellation_at
      DateTimeHelper.to_rfc3339(scheduled_cancellation_at)
    end
  end
end
