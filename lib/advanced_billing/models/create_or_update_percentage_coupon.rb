# advanced_billing
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module AdvancedBilling
  # CreateOrUpdatePercentageCoupon Model.
  class CreateOrUpdatePercentageCoupon < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # the name of the coupon
    # @return [String]
    attr_accessor :name

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [String]
    attr_accessor :code

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [String]
    attr_accessor :description

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [Object]
    attr_accessor :percentage

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [String]
    attr_accessor :allow_negative_balance

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [String]
    attr_accessor :recurring

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [String]
    attr_accessor :end_date

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [String]
    attr_accessor :product_family_id

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [String]
    attr_accessor :stackable

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [CompoundingStrategy]
    attr_accessor :compounding_strategy

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [TrueClass | FalseClass]
    attr_accessor :exclude_mid_period_allocations

    # may contain uppercase alphanumeric characters and these special characters
    # (which allow for email addresses to be used): “%”, “@”, “+”, “-”, “_”, and
    # “.”
    # @return [TrueClass | FalseClass]
    attr_accessor :apply_on_cancel_at_end_of_period

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['name'] = 'name'
      @_hash['code'] = 'code'
      @_hash['description'] = 'description'
      @_hash['percentage'] = 'percentage'
      @_hash['allow_negative_balance'] = 'allow_negative_balance'
      @_hash['recurring'] = 'recurring'
      @_hash['end_date'] = 'end_date'
      @_hash['product_family_id'] = 'product_family_id'
      @_hash['stackable'] = 'stackable'
      @_hash['compounding_strategy'] = 'compounding_strategy'
      @_hash['exclude_mid_period_allocations'] =
        'exclude_mid_period_allocations'
      @_hash['apply_on_cancel_at_end_of_period'] =
        'apply_on_cancel_at_end_of_period'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        description
        allow_negative_balance
        recurring
        end_date
        product_family_id
        stackable
        compounding_strategy
        exclude_mid_period_allocations
        apply_on_cancel_at_end_of_period
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(name = nil,
                   code = nil,
                   percentage = nil,
                   description = SKIP,
                   allow_negative_balance = SKIP,
                   recurring = SKIP,
                   end_date = SKIP,
                   product_family_id = SKIP,
                   stackable = SKIP,
                   compounding_strategy = SKIP,
                   exclude_mid_period_allocations = SKIP,
                   apply_on_cancel_at_end_of_period = SKIP)
      @name = name
      @code = code
      @description = description unless description == SKIP
      @percentage = percentage
      @allow_negative_balance = allow_negative_balance unless allow_negative_balance == SKIP
      @recurring = recurring unless recurring == SKIP
      @end_date = end_date unless end_date == SKIP
      @product_family_id = product_family_id unless product_family_id == SKIP
      @stackable = stackable unless stackable == SKIP
      @compounding_strategy = compounding_strategy unless compounding_strategy == SKIP
      unless exclude_mid_period_allocations == SKIP
        @exclude_mid_period_allocations =
          exclude_mid_period_allocations
      end
      unless apply_on_cancel_at_end_of_period == SKIP
        @apply_on_cancel_at_end_of_period =
          apply_on_cancel_at_end_of_period
      end
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      name = hash.key?('name') ? hash['name'] : nil
      code = hash.key?('code') ? hash['code'] : nil
      percentage = hash.key?('percentage') ? APIHelper.deserialize_union_type(
        UnionTypeLookUp.get(:CreateOrUpdatePercentageCouponPercentage), hash['percentage']
      ) : nil
      description = hash.key?('description') ? hash['description'] : SKIP
      allow_negative_balance =
        hash.key?('allow_negative_balance') ? hash['allow_negative_balance'] : SKIP
      recurring = hash.key?('recurring') ? hash['recurring'] : SKIP
      end_date = hash.key?('end_date') ? hash['end_date'] : SKIP
      product_family_id =
        hash.key?('product_family_id') ? hash['product_family_id'] : SKIP
      stackable = hash.key?('stackable') ? hash['stackable'] : SKIP
      compounding_strategy = hash.key?('compounding_strategy') ? APIHelper.deserialize_union_type(
        UnionTypeLookUp.get(:CreateOrUpdatePercentageCouponCompoundingStrategy), hash['compounding_strategy']
      ) : SKIP
      exclude_mid_period_allocations =
        hash.key?('exclude_mid_period_allocations') ? hash['exclude_mid_period_allocations'] : SKIP
      apply_on_cancel_at_end_of_period =
        hash.key?('apply_on_cancel_at_end_of_period') ? hash['apply_on_cancel_at_end_of_period'] : SKIP

      # Create object from extracted values.
      CreateOrUpdatePercentageCoupon.new(name,
                                         code,
                                         percentage,
                                         description,
                                         allow_negative_balance,
                                         recurring,
                                         end_date,
                                         product_family_id,
                                         stackable,
                                         compounding_strategy,
                                         exclude_mid_period_allocations,
                                         apply_on_cancel_at_end_of_period)
    end

    # Validates an instance of the object from a given value.
    # @param [CreateOrUpdatePercentageCoupon | Hash] The value against the validation is performed.
    def self.validate(value)
      if value.instance_of? self
        return (
          APIHelper.valid_type?(value.name,
                                ->(val) { val.instance_of? String }) and
            APIHelper.valid_type?(value.code,
                                  ->(val) { val.instance_of? String }) and
            UnionTypeLookUp.get(:CreateOrUpdatePercentageCouponPercentage)
                           .validate(value.percentage)
        )
      end

      return false unless value.instance_of? Hash

      (
        APIHelper.valid_type?(value['name'],
                              ->(val) { val.instance_of? String }) and
          APIHelper.valid_type?(value['code'],
                                ->(val) { val.instance_of? String }) and
          UnionTypeLookUp.get(:CreateOrUpdatePercentageCouponPercentage)
                         .validate(value['percentage'])
      )
    end
  end
end
