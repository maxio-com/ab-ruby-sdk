# advanced_billing
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module AdvancedBilling
  # RenewalPreview Model.
  class RenewalPreview < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # The timestamp for the subscription’s next renewal
    # @return [String]
    attr_accessor :next_assessment_at

    # An integer representing the amount of the total pre-tax, pre-discount
    # charges that will be assessed at the next renewal
    # @return [Integer]
    attr_accessor :subtotal_in_cents

    # An integer representing the total tax charges that will be assessed at the
    # next renewal
    # @return [Integer]
    attr_accessor :total_tax_in_cents

    # An integer representing the amount of the coupon discounts that will be
    # applied to the next renewal
    # @return [Integer]
    attr_accessor :total_discount_in_cents

    # An integer representing the total amount owed, less any discounts, that
    # will be assessed at the next renewal
    # @return [Integer]
    attr_accessor :total_in_cents

    # An integer representing the amount of the subscription’s current balance
    # @return [Integer]
    attr_accessor :existing_balance_in_cents

    # An integer representing the existing_balance_in_cents plus the
    # total_in_cents
    # @return [Integer]
    attr_accessor :total_amount_due_in_cents

    # A boolean indicating whether or not additional taxes will be calculated at
    # the time of renewal. This will be true if you are using Avalara and the
    # address of the subscription is in one of your defined taxable regions.
    # @return [TrueClass | FalseClass]
    attr_accessor :uncalculated_taxes

    # An array of objects representing the individual transactions that will be
    # created at the next renewal
    # @return [Array[RenewalPreviewLineItem]]
    attr_accessor :line_items

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['next_assessment_at'] = 'next_assessment_at'
      @_hash['subtotal_in_cents'] = 'subtotal_in_cents'
      @_hash['total_tax_in_cents'] = 'total_tax_in_cents'
      @_hash['total_discount_in_cents'] = 'total_discount_in_cents'
      @_hash['total_in_cents'] = 'total_in_cents'
      @_hash['existing_balance_in_cents'] = 'existing_balance_in_cents'
      @_hash['total_amount_due_in_cents'] = 'total_amount_due_in_cents'
      @_hash['uncalculated_taxes'] = 'uncalculated_taxes'
      @_hash['line_items'] = 'line_items'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        next_assessment_at
        subtotal_in_cents
        total_tax_in_cents
        total_discount_in_cents
        total_in_cents
        existing_balance_in_cents
        total_amount_due_in_cents
        uncalculated_taxes
        line_items
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(next_assessment_at = SKIP,
                   subtotal_in_cents = SKIP,
                   total_tax_in_cents = SKIP,
                   total_discount_in_cents = SKIP,
                   total_in_cents = SKIP,
                   existing_balance_in_cents = SKIP,
                   total_amount_due_in_cents = SKIP,
                   uncalculated_taxes = SKIP,
                   line_items = SKIP)
      @next_assessment_at = next_assessment_at unless next_assessment_at == SKIP
      @subtotal_in_cents = subtotal_in_cents unless subtotal_in_cents == SKIP
      @total_tax_in_cents = total_tax_in_cents unless total_tax_in_cents == SKIP
      @total_discount_in_cents = total_discount_in_cents unless total_discount_in_cents == SKIP
      @total_in_cents = total_in_cents unless total_in_cents == SKIP
      unless existing_balance_in_cents == SKIP
        @existing_balance_in_cents =
          existing_balance_in_cents
      end
      unless total_amount_due_in_cents == SKIP
        @total_amount_due_in_cents =
          total_amount_due_in_cents
      end
      @uncalculated_taxes = uncalculated_taxes unless uncalculated_taxes == SKIP
      @line_items = line_items unless line_items == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      next_assessment_at =
        hash.key?('next_assessment_at') ? hash['next_assessment_at'] : SKIP
      subtotal_in_cents =
        hash.key?('subtotal_in_cents') ? hash['subtotal_in_cents'] : SKIP
      total_tax_in_cents =
        hash.key?('total_tax_in_cents') ? hash['total_tax_in_cents'] : SKIP
      total_discount_in_cents =
        hash.key?('total_discount_in_cents') ? hash['total_discount_in_cents'] : SKIP
      total_in_cents =
        hash.key?('total_in_cents') ? hash['total_in_cents'] : SKIP
      existing_balance_in_cents =
        hash.key?('existing_balance_in_cents') ? hash['existing_balance_in_cents'] : SKIP
      total_amount_due_in_cents =
        hash.key?('total_amount_due_in_cents') ? hash['total_amount_due_in_cents'] : SKIP
      uncalculated_taxes =
        hash.key?('uncalculated_taxes') ? hash['uncalculated_taxes'] : SKIP
      # Parameter is an array, so we need to iterate through it
      line_items = nil
      unless hash['line_items'].nil?
        line_items = []
        hash['line_items'].each do |structure|
          line_items << (RenewalPreviewLineItem.from_hash(structure) if structure)
        end
      end

      line_items = SKIP unless hash.key?('line_items')

      # Create object from extracted values.
      RenewalPreview.new(next_assessment_at,
                         subtotal_in_cents,
                         total_tax_in_cents,
                         total_discount_in_cents,
                         total_in_cents,
                         existing_balance_in_cents,
                         total_amount_due_in_cents,
                         uncalculated_taxes,
                         line_items)
    end
  end
end
