# advanced_billing
#
# This file was automatically generated by APIMATIC v2.0
# ( https://apimatic.io ).

module AdvancedBilling
  # DebitNote Model.
  class DebitNote < BaseModel
    SKIP = Object.new
    private_constant :SKIP

    # Unique identifier for the debit note. It is generated automatically by
    # Chargify and has the prefix "db_" followed by alphanumeric characters.
    # @return [String]
    attr_accessor :uid

    # ID of the site to which the debit note belongs.
    # @return [Integer]
    attr_accessor :site_id

    # ID of the customer to which the debit note belongs.
    # @return [Integer]
    attr_accessor :customer_id

    # ID of the subscription that generated the debit note.
    # @return [Integer]
    attr_accessor :subscription_id

    # A unique, identifier that appears on the debit note and in places it is
    # referenced.
    # @return [Integer]
    attr_accessor :number

    # A monotonically increasing number assigned to debit notes as they are
    # created.
    # @return [Integer]
    attr_accessor :sequence_number

    # Unique identifier for the connected credit note. It is generated
    # automatically by Chargify and has the prefix "cn_" followed by
    # alphanumeric characters.
    # While the UID is long and not appropriate to show to customers, the number
    # is usually shorter and consumable by the customer and the merchant alike.
    # @return [String]
    attr_accessor :origin_credit_note_uid

    # A unique, identifying string of the connected credit note.
    # @return [String]
    attr_accessor :origin_credit_note_number

    # Date the document was issued to the customer. This is the date that the
    # document was made available for payment.
    # The format is "YYYY-MM-DD".
    # @return [Date]
    attr_accessor :issue_date

    # Debit notes are applied to invoices to offset invoiced amounts - they
    # adjust the amount due. This field is the date the debit note document
    # became fully applied to the invoice.
    # The format is "YYYY-MM-DD".
    # @return [Date]
    attr_accessor :applied_date

    # Date the document is due for payment. The format is "YYYY-MM-DD".
    # @return [Date]
    attr_accessor :due_date

    # Current status of the debit note.
    # @return [DebitNoteStatus]
    attr_accessor :status

    # The memo printed on debit note, which is a description of the reason for
    # the debit.
    # @return [String]
    attr_accessor :memo

    # The role of the debit note.
    # @return [DebitNoteRole]
    attr_accessor :role

    # The ISO 4217 currency code (3 character string) representing the currency
    # of the credit note amount fields.
    # @return [String]
    attr_accessor :currency

    # Information about the seller (merchant) listed on the masthead of the
    # debit note.
    # @return [InvoiceSeller]
    attr_accessor :seller

    # Information about the customer who is owner or recipient the debited
    # subscription.
    # @return [InvoiceCustomer]
    attr_accessor :customer

    # The billing address of the debited subscription.
    # @return [InvoiceAddress]
    attr_accessor :billing_address

    # The shipping address of the debited subscription.
    # @return [InvoiceAddress]
    attr_accessor :shipping_address

    # Line items on the debit note.
    # @return [Array[CreditNoteLineItem]]
    attr_accessor :line_items

    # Line items on the debit note.
    # @return [Array[InvoiceDiscount]]
    attr_accessor :discounts

    # Line items on the debit note.
    # @return [Array[InvoiceTax]]
    attr_accessor :taxes

    # Line items on the debit note.
    # @return [Array[InvoiceRefund]]
    attr_accessor :refunds

    # A mapping from model property names to API property names.
    def self.names
      @_hash = {} if @_hash.nil?
      @_hash['uid'] = 'uid'
      @_hash['site_id'] = 'site_id'
      @_hash['customer_id'] = 'customer_id'
      @_hash['subscription_id'] = 'subscription_id'
      @_hash['number'] = 'number'
      @_hash['sequence_number'] = 'sequence_number'
      @_hash['origin_credit_note_uid'] = 'origin_credit_note_uid'
      @_hash['origin_credit_note_number'] = 'origin_credit_note_number'
      @_hash['issue_date'] = 'issue_date'
      @_hash['applied_date'] = 'applied_date'
      @_hash['due_date'] = 'due_date'
      @_hash['status'] = 'status'
      @_hash['memo'] = 'memo'
      @_hash['role'] = 'role'
      @_hash['currency'] = 'currency'
      @_hash['seller'] = 'seller'
      @_hash['customer'] = 'customer'
      @_hash['billing_address'] = 'billing_address'
      @_hash['shipping_address'] = 'shipping_address'
      @_hash['line_items'] = 'line_items'
      @_hash['discounts'] = 'discounts'
      @_hash['taxes'] = 'taxes'
      @_hash['refunds'] = 'refunds'
      @_hash
    end

    # An array for optional fields
    def self.optionals
      %w[
        uid
        site_id
        customer_id
        subscription_id
        number
        sequence_number
        origin_credit_note_uid
        origin_credit_note_number
        issue_date
        applied_date
        due_date
        status
        memo
        role
        currency
        seller
        customer
        billing_address
        shipping_address
        line_items
        discounts
        taxes
        refunds
      ]
    end

    # An array for nullable fields
    def self.nullables
      []
    end

    def initialize(uid: SKIP, site_id: SKIP, customer_id: SKIP,
                   subscription_id: SKIP, number: SKIP, sequence_number: SKIP,
                   origin_credit_note_uid: SKIP,
                   origin_credit_note_number: SKIP, issue_date: SKIP,
                   applied_date: SKIP, due_date: SKIP, status: SKIP, memo: SKIP,
                   role: SKIP, currency: SKIP, seller: SKIP, customer: SKIP,
                   billing_address: SKIP, shipping_address: SKIP,
                   line_items: SKIP, discounts: SKIP, taxes: SKIP,
                   refunds: SKIP, additional_properties: {})
      # Add additional model properties to the instance.
      additional_properties.each do |_name, _value|
        instance_variable_set("@#{_name}", _value)
      end

      @uid = uid unless uid == SKIP
      @site_id = site_id unless site_id == SKIP
      @customer_id = customer_id unless customer_id == SKIP
      @subscription_id = subscription_id unless subscription_id == SKIP
      @number = number unless number == SKIP
      @sequence_number = sequence_number unless sequence_number == SKIP
      @origin_credit_note_uid = origin_credit_note_uid unless origin_credit_note_uid == SKIP
      unless origin_credit_note_number == SKIP
        @origin_credit_note_number =
          origin_credit_note_number
      end
      @issue_date = issue_date unless issue_date == SKIP
      @applied_date = applied_date unless applied_date == SKIP
      @due_date = due_date unless due_date == SKIP
      @status = status unless status == SKIP
      @memo = memo unless memo == SKIP
      @role = role unless role == SKIP
      @currency = currency unless currency == SKIP
      @seller = seller unless seller == SKIP
      @customer = customer unless customer == SKIP
      @billing_address = billing_address unless billing_address == SKIP
      @shipping_address = shipping_address unless shipping_address == SKIP
      @line_items = line_items unless line_items == SKIP
      @discounts = discounts unless discounts == SKIP
      @taxes = taxes unless taxes == SKIP
      @refunds = refunds unless refunds == SKIP
    end

    # Creates an instance of the object from a hash.
    def self.from_hash(hash)
      return nil unless hash

      # Extract variables from the hash.
      uid = hash.key?('uid') ? hash['uid'] : SKIP
      site_id = hash.key?('site_id') ? hash['site_id'] : SKIP
      customer_id = hash.key?('customer_id') ? hash['customer_id'] : SKIP
      subscription_id =
        hash.key?('subscription_id') ? hash['subscription_id'] : SKIP
      number = hash.key?('number') ? hash['number'] : SKIP
      sequence_number =
        hash.key?('sequence_number') ? hash['sequence_number'] : SKIP
      origin_credit_note_uid =
        hash.key?('origin_credit_note_uid') ? hash['origin_credit_note_uid'] : SKIP
      origin_credit_note_number =
        hash.key?('origin_credit_note_number') ? hash['origin_credit_note_number'] : SKIP
      issue_date = hash.key?('issue_date') ? hash['issue_date'] : SKIP
      applied_date = hash.key?('applied_date') ? hash['applied_date'] : SKIP
      due_date = hash.key?('due_date') ? hash['due_date'] : SKIP
      status = hash.key?('status') ? hash['status'] : SKIP
      memo = hash.key?('memo') ? hash['memo'] : SKIP
      role = hash.key?('role') ? hash['role'] : SKIP
      currency = hash.key?('currency') ? hash['currency'] : SKIP
      seller = InvoiceSeller.from_hash(hash['seller']) if hash['seller']
      customer = InvoiceCustomer.from_hash(hash['customer']) if hash['customer']
      billing_address = InvoiceAddress.from_hash(hash['billing_address']) if
        hash['billing_address']
      shipping_address = InvoiceAddress.from_hash(hash['shipping_address']) if
        hash['shipping_address']
      # Parameter is an array, so we need to iterate through it
      line_items = nil
      unless hash['line_items'].nil?
        line_items = []
        hash['line_items'].each do |structure|
          line_items << (CreditNoteLineItem.from_hash(structure) if structure)
        end
      end

      line_items = SKIP unless hash.key?('line_items')
      # Parameter is an array, so we need to iterate through it
      discounts = nil
      unless hash['discounts'].nil?
        discounts = []
        hash['discounts'].each do |structure|
          discounts << (InvoiceDiscount.from_hash(structure) if structure)
        end
      end

      discounts = SKIP unless hash.key?('discounts')
      # Parameter is an array, so we need to iterate through it
      taxes = nil
      unless hash['taxes'].nil?
        taxes = []
        hash['taxes'].each do |structure|
          taxes << (InvoiceTax.from_hash(structure) if structure)
        end
      end

      taxes = SKIP unless hash.key?('taxes')
      # Parameter is an array, so we need to iterate through it
      refunds = nil
      unless hash['refunds'].nil?
        refunds = []
        hash['refunds'].each do |structure|
          refunds << (InvoiceRefund.from_hash(structure) if structure)
        end
      end

      refunds = SKIP unless hash.key?('refunds')

      # Clean out expected properties from Hash.
      additional_properties = hash.reject { |k, _| names.value?(k) }

      # Create object from extracted values.
      DebitNote.new(uid: uid,
                    site_id: site_id,
                    customer_id: customer_id,
                    subscription_id: subscription_id,
                    number: number,
                    sequence_number: sequence_number,
                    origin_credit_note_uid: origin_credit_note_uid,
                    origin_credit_note_number: origin_credit_note_number,
                    issue_date: issue_date,
                    applied_date: applied_date,
                    due_date: due_date,
                    status: status,
                    memo: memo,
                    role: role,
                    currency: currency,
                    seller: seller,
                    customer: customer,
                    billing_address: billing_address,
                    shipping_address: shipping_address,
                    line_items: line_items,
                    discounts: discounts,
                    taxes: taxes,
                    refunds: refunds,
                    additional_properties: additional_properties)
    end

    # Validates an instance of the object from a given value.
    # @param [DebitNote | Hash] The value against the validation is performed.
    def self.validate(value)
      return true if value.instance_of? self

      return false unless value.instance_of? Hash

      true
    end

    # Provides a human-readable string representation of the object.
    def to_s
      class_name = self.class.name.split('::').last
      "<#{class_name} uid: #{@uid}, site_id: #{@site_id}, customer_id: #{@customer_id},"\
      " subscription_id: #{@subscription_id}, number: #{@number}, sequence_number:"\
      " #{@sequence_number}, origin_credit_note_uid: #{@origin_credit_note_uid},"\
      " origin_credit_note_number: #{@origin_credit_note_number}, issue_date: #{@issue_date},"\
      " applied_date: #{@applied_date}, due_date: #{@due_date}, status: #{@status}, memo:"\
      " #{@memo}, role: #{@role}, currency: #{@currency}, seller: #{@seller}, customer:"\
      " #{@customer}, billing_address: #{@billing_address}, shipping_address:"\
      " #{@shipping_address}, line_items: #{@line_items}, discounts: #{@discounts}, taxes:"\
      " #{@taxes}, refunds: #{@refunds}, additional_properties: #{get_additional_properties}>"
    end

    # Provides a debugging-friendly string with detailed object information.
    def inspect
      class_name = self.class.name.split('::').last
      "<#{class_name} uid: #{@uid.inspect}, site_id: #{@site_id.inspect}, customer_id:"\
      " #{@customer_id.inspect}, subscription_id: #{@subscription_id.inspect}, number:"\
      " #{@number.inspect}, sequence_number: #{@sequence_number.inspect}, origin_credit_note_uid:"\
      " #{@origin_credit_note_uid.inspect}, origin_credit_note_number:"\
      " #{@origin_credit_note_number.inspect}, issue_date: #{@issue_date.inspect}, applied_date:"\
      " #{@applied_date.inspect}, due_date: #{@due_date.inspect}, status: #{@status.inspect},"\
      " memo: #{@memo.inspect}, role: #{@role.inspect}, currency: #{@currency.inspect}, seller:"\
      " #{@seller.inspect}, customer: #{@customer.inspect}, billing_address:"\
      " #{@billing_address.inspect}, shipping_address: #{@shipping_address.inspect}, line_items:"\
      " #{@line_items.inspect}, discounts: #{@discounts.inspect}, taxes: #{@taxes.inspect},"\
      " refunds: #{@refunds.inspect}, additional_properties: #{get_additional_properties}>"
    end
  end
end
